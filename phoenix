#!/usr/bin/env node
var nomnom     = require('nomnom');
var proquint   = require('proquint-');
var fs         = require('fs');
var pull       = require('pull-stream');
var prettydate = require('pretty-date');
var celeri     = require('celeri');
var keys       = require('./js/common/keys');
var ssb        = require('./js/common/ssb');
var netnodes   = require('./js/common/network-nodes');

function namefileHelp() {
	console.log('You don\'t have a ~/.scuttlebutt/secret.name yet; run the \'init\' command.');
}

function padleft(width, str) {
	if (str.length < width) {
		return '                                        '.slice(0, width - str.length) + str;
	}
	return str;
}


//see http://en.wikipedia.org/wiki/Box-drawing_characters

celeri.drawTree = celeri.tree = function(tree, path, ops, tab) {
	if(!ops) ops = {};
	if (!path) path = [0];

	// abort at end of path
	if (!path.length) return;
	path = path.slice(1);
	var expanded_node = path.length ? path[0] : -1;
	var last_node = (path.length == 0);

	var parts = { };

	if(ops.pretty) {
		parts = {
			pipe: '|',
			tee: '┬',
			dash: '─',
			leftCorner: '└',
			left: '├',
			branch: utils.repeat('─', 1)
		}

	//plays a little more nicely with fonts such as terminus
	} else {
		parts = {
			pipe: '|',
			tee: '+',
			dash: '-',
			leftCorner: '+',
			left: '|',
			branch: utils.repeat('-', 1)
		}
	}

	Structr.copy(ops.parts || {}, parts);

	parts.tabs = utils.repeat(' ',parts.branch.length+1);

	if(!tab) tab = '';

	var n = utils.objectSize(tree),
	i = 0,
	printedBreak = false;


	for(var index in tree) {

		var expanded = (i == expanded_node);
		var childrenOrValue = tree[index],
		toc = typeof childrenOrValue,
		toi = typeof index,
		edge = i < n-1 ? parts.left : parts.leftCorner;


		var value;
		switch (toc) {
			case 'function':
				if (childrenOrValue.title && typeof childrenOrValue.title == 'string') {
					value = childrenOrValue.title.grey;
				} else {
					value = 'Function'.grey;
				}
				break;

			default:
				value = (''+JSON.stringify(childrenOrValue)).grey;
		}
		var line = !isNaN(Number(index)) ?  value : (index.green + ': ' + value);


		if (toc == 'object' && childrenOrValue && Object.keys(childrenOrValue).length) {
			console.log('%s%s %s', tab, (edge + parts.branch + parts.tee).white, index + '...');
		} else {
			console.log('%s%s %s', tab, (edge + parts.branch + parts.dash).white, line);
		}

		if(toc == 'object' && expanded) {
			printedBreak = celeri.drawTree(childrenOrValue, path, ops, n > 1 && i < n-1 ? tab + parts.pipe + parts.tabs.substr(1) : tab + parts.tabs);
		}

		 i++;
	}


	//add extra breaks for folders - a little more readable
	if(!printedBreak) {
		console.log('%s',tab);
		printedBreak = true;
	}

	return printedBreak;
};

function commander(opts) {
	celeri.drawTree(require('./js/apps'), [0, 0], { pretty: false });
}

function init(opts) {
	// Setup keys
	keys.create(opts['force-new-keypair'], function(err) {
		if (err) {
			if (err.fatal) {
				console.error(err.toString());
				return;
			}
			console.error('Warning' + err.toString().slice(5));
		}
		console.log('Keypair created.');
		console.log('You are:    ' + keys.name.toString('hex'));
		console.log('Public key: ' + keys.public.toString('hex'));
	});
}

function whoami(opts) {
	if (keys.exist) {
		console.log('You are:    ' + keys.name.toString('hex'));
		console.log('Public key: ' + keys.public.toString('hex'));
	} else {
		namefileHelp();
	}
}

function list(opts) {
	function toDetailed (msg) {
		var author = msg.author.toString('hex');
		console.log (
			//proquint.encodeCamelDash(msg.author).substring(0, 43) + ' / ' +
			author.slice(0, 12) + '...' + author.slice(-4) + ' / ' +
			msg.sequence + '\n' +
			msg.type.toString('utf8') + ' : '+
			new Date(msg.timestamp).toISOString() + '\n' +
			( msg.type.toString('utf8') == 'init'
			? msg.message.toString('hex') + '\n'
			: msg.message.toString('utf8') + '\n' )
		);
	}
	function toSimple(msg) {
		var author = msg.author.toString('hex');
		var output =
			author.slice(0, 12) + '...' + author.slice(-4) + ' | ' +
			padleft(14, prettydate.format(new Date(msg.timestamp))) + ' | '
		;
		switch (msg.type.toString('utf8')) {
			case 'init':
				output += '[Account created]';
				break;
			case 'text':
				output += msg.message.toString('utf8');
				break;
			default:
				output += msg.type.toString('utf8') + ' - ' + msg.message.toString('utf8');
		}
		console.log(output);
	}
	pull(
		ssb.createFeedStream(),
		pull.map((opts.long) ? toDetailed : toSimple),
		pull.drain()
	);
}

function feeds(opts) {
	pull(
		ssb.following(),
		pull.collect(function(err, entries) {
			if (err) { return console.error(err); }
			// :TODO: nicknames
			console.log ('  nickname  id');
			entries.forEach(function(entry, i) {
				console.log((i+1) + ' ???       ' + entry.key.toString('hex'));
			});
		})
	);
}

function lookup(opts) {
	var name = opts.name;

	function output(entry) {
		var id = entry.key;
		if (opts.pubkey) {
			ssb.getPublicKey(id, function(err, pubkey) {
				if (err) { return console.error(err); }
				console.log(pubkey.toString('hex'));
			});
		} else {
			console.log(id.toString('hex'));
		}
	}

	if (+name == name) {
		// numeric
		var id = (+name - 1);
		pull(
			ssb.following(),
			pull.collect(function(err, entries) {
				if (err) { return console.error(err); }
				var entry = entries[id];
				if (!entry) { return console.error('Invalid user number.'); }
				output(entry);
			})
		);
	} else {
		// :TODO: names
		console.log('Names are not yet implemented');
	}
}

function post(opts) {
	if (!keys.exist) {
		return namefileHelp();
	}

	var feed = ssb.createFeed(keys);
	feed.add('text', opts.text, function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});
}

function follow(opts) {
	// Validate key
	// :TODO:

	// Add to follow list
	ssb.follow(new Buffer(opts.key, 'hex'), function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});
}

function unfollow(opts) {
	// :TODO: reference by number or name

	// Remove from follow list
	ssb.unfollow(opts.key, function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});
}

function sign(opts) {
	console.log('Signing ' + opts.path);

	if (!keys.exist) {
		return namefileHelp();
	}

	var buffer;
	try {
		buffer = fs.readFileSync(opts.path);
	} catch (e) {
		console.error('Error: File not found');
		return;
	}

	var sig = keys.sign(buffer);
	console.log('Signature: ' + sig.toString('hex'));
}

function verify(opts) {
	console.log('Verifying ' + opts.path);

	var key = opts.key || keys.public;
	if (!key) {
		return namefileHelp();
	}

	var buffer;
	try {
		buffer = fs.readFileSync(opts.path);
	} catch (e) {
		console.error('Error: File not found');
		return;
	}

	if (keys.verify(buffer, new Buffer(opts.sig, 'hex'), key)) {
		console.log('Success: Signature checks out.');
	} else {
		console.log('Failure: Signature does not match.');
	}
}

function addNode(opts) {
	var host = opts.host.split(':');
	var addr = host[0];
	var port = host[1] || 64000;

	netnodes.add(addr, port, function(err) {
		if (err) { return console.error(err); }
		console.log('Ok.');
	});
}

function delNode(opts) {
	var host = opts.host.split(':');
	var addr = host[0];
	var port = host[1] || 64000;

	netnodes.del(addr, port, function(err) {
		if (err) { return console.error(err); }
		console.log('Ok.');
	});
}

function listNodes(opts) {
	pull(
		netnodes.createListStream(),
		pull.through(function(node) {
			console.log(node.key[0] + ':' + node.key[1]);
		}),
		pull.drain()
	);
}

nomnom.script('phoenix');
nomnom.nocommand().callback(commander);
nomnom.command('init')
	.help('Sets up phoenix.')
	.option('force-new-keypair', {
		flag: true,
		help: 'Overwrites your ~/.scuttlebutt/secret.name file with a new keypair if it already exists.'
	})
	.callback(init);
nomnom.command('whoami')
	.help('Lists your profile.')
	.callback(whoami);
nomnom.command('list')
	.help('Lists the feed messages.')
	.options({
		long: {
			flag: true,
			help: 'Flag, output more detailed information.'
		}
	})
	.callback(list);
nomnom.command('feeds')
	.help('Lists the users you follow.')
	.callback(feeds);
nomnom.command('lookup')
	.help('Looks up a user by a nickname.')
	.options({
		name: {
			position: 1,
			required: true,
			help: 'Nickname or user number to lookup.',
		},
		pubkey: {
			flag: true,
			help: 'Flag, output the user\'s public key rather than their id.'
		}
	})
	.callback(lookup);
nomnom.command('post')
	.help('Posts a message to your feed.')
	.options({
		text: {
			position: 1,
			required: true,
			help: 'Message-text to post.'
		}
	})
	.callback(post);
nomnom.command('follow')
	.help('Starts following a user.')
	.options({
		key: {
			position: 1,
			required: true,
			help: 'Public key to follow.'
		}
	})
	.callback(follow);
nomnom.command('unfollow')
	.help('Stops following a user.')
	.options({
		key: {
			position: 1,
			required: true,
			help: 'Public key to unfollow.'
		}
	})
	.callback(unfollow);
nomnom.command('sign')
	.help('Creates a signature for a file.')
	.options({
		path: {
			position: 1,
			required: true,
			help: 'File to sign.',
		}
	})
	.callback(sign);
nomnom.command('verify')
	.help('Verifies a signature for a file.')
	.options({
		path: {
			position: 1,
			required: true,
			help: 'File to verify.',
		},
		sig: {
			position: 2,
			required: true,
			help: 'Signature to verify (hex-encoded).',
		},
		key: {
			position: 3,
			help: 'Public key of the user who created the signature (defaults to yours).'
		}
	})
	.callback(verify);
nomnom.command('add-node')
	.help('Manually adds a node to your replication network.')
	.options({
		host: {
			position: 1,
			required: true,
			help: 'Address of the node (<address>[:port]).',
		}
	})
	.callback(addNode);
nomnom.command('del-node')
	.help('Manually removes a node from your replication network.')
	.options({
		host: {
			position: 1,
			required: true,
			help: 'Address of the node (<address>[:port]).',
		}
	})
	.callback(delNode);
nomnom.command('list-nodes')
	.help('Lists the nodes in your replication network.')
	.callback(listNodes);
nomnom.parse();